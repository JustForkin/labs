'use strict';var THREE,env,terrain,TERRAIN={REVISION:"0.1",Generate:function(a,b){this.main=a;this.debug=!0;b=b||{};this.div=b.div||[256,256];this.size=b.size||[50,10,50];this.isAutoMove=b.AutoMove||!1;this.isMove=b.Move||!1;this.ratio=0;this.hfFloatBuffer=null;this.mapOffset=20;this.specularMap=this.normalMap=this.heightMap=null;this.mlib={};this.textureCounter=0;this.cameraOrtho=this.sceneRenderTarget=null;this.H=this.W=0;this.quadTarget=null;this.animDelta=0;this.animDeltaDir=-1;this.lightVal=
0;this.lightDir=1;this.pos={x:0,y:0};this.ease={x:0,y:0};this.maxspeed=2;this.dec=this.acc=0.1;this.updateNoise=!0;this.tmpData=this.terrainShader=this.specularShader=this.normalShader=this.noiseShader=null;this.isWithDepthTest=!0;this.textures=[];this.maps="level0 level1 level2 level3 level4 diffuse1 diffuse2 normal".split(" ");this.fullLoaded=!1;this.end=this.timerTest=null;this.init()}};
TERRAIN.Generate.prototype={constructor:TERRAIN.Generate,load:function(a){this.end=a;for(a=this.maps.length;a--;)this.textures[a]=new THREE.ImageUtils.loadTexture("images/terrain/"+this.maps[a]+".jpg");this.timerTest=setInterval(this.loadTextures,20,this)},loadTextures:function(a){if(a.textures.length==a.maps.length){clearInterval(a.timerTest);for(var b=a.textures.length;b--;)a.textures[b].format=THREE.RGBFormat,a.textures[b].wrapS=a.textures[b].wrapT=THREE.RepeatWrapping;a.start()}},clear:function(){this.container.remove(this.mesh);
this.mesh.geometry.dispose();this.mlib.heightmap.dispose();this.mlib.normal.dispose();this.mlib.terrain.dispose()},init:function(){this.ratio=this.size[1]/765;this.hfFloatBuffer=new Float32Array(this.div[0]*this.div[1]);var a=new THREE.PlaneBufferGeometry(this.size[0],this.size[2],this.div[0]-1,this.div[1]-1);this.mesh=new THREE.Mesh(a,new THREE.MeshBasicMaterial({color:16733525}));this.mesh.rotation.x=-Math.PI/2;this.mesh.geometry.computeTangents();this.mesh.visible=!1;this.mesh.castShadow=!0;this.mesh.receiveShadow=
!0;this.container=new THREE.Group;this.container.add(this.mesh);this.main.scene.add(this.container);this.W=this.main.dimentions.w||512;this.H=this.main.dimentions.h||512;this.load();this.debug&&(a=new THREE.PlaneBufferGeometry(0.25*this.size[0],0.25*this.size[2]),this.m1=new THREE.Mesh(a,new THREE.MeshBasicMaterial({color:16777215})),this.m2=new THREE.Mesh(a,new THREE.MeshBasicMaterial({color:16777215})),this.m3=new THREE.Mesh(a,new THREE.MeshBasicMaterial({color:16777215})),this.container.add(this.m1),
this.container.add(this.m2),this.container.add(this.m3),this.m2.position.set(0,0,0.75*this.size[0]),this.m1.position.set(0.25*-this.size[0],0,0.75*this.size[0]),this.m3.position.set(0.25*this.size[0],0,0.75*this.size[0]),this.m1.rotation.x=-Math.PI/4,this.m2.rotation.x=-Math.PI/4,this.m3.rotation.x=-Math.PI/4,this.m1.visible=!1,this.m2.visible=!1,this.m3.visible=!1)},start:function(){this.isWithDepthTest&&(this.tmpData=new Uint8Array(this.div[0]*this.div[1]*4));this.sceneRenderTarget=new THREE.Scene;
this.cameraOrtho=new THREE.OrthographicCamera(this.W/-2,this.W/2,this.H/2,this.H/-2,-1E4,1E4);this.cameraOrtho.position.z=100;this.sceneRenderTarget.add(this.cameraOrtho);this.normalShader=TERRAIN.NormalMapShader;var a={minFilter:THREE.LinearMipmapLinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this.heightMap=new THREE.WebGLRenderTarget(this.div[0],this.div[1],a);this.normalMap=new THREE.WebGLRenderTarget(this.div[0],this.div[1],a);this.specularMap=new THREE.WebGLRenderTarget(this.div[0],
this.div[1],a);this.normalShader.uniforms.height.value=0.05;this.normalShader.uniforms.resolution.value.set(this.div[0],this.div[1]);this.normalShader.uniforms.scale.value.set(1,1);this.normalShader.uniforms.heightMap.value=this.heightMap;this.noiseShader=TERRAIN.ShaderNoise;this.specularShader=TERRAIN.LuminosityShader;this.specularShader.uniforms.tDiffuse.value=this.normalMap;this.terrainShader=TERRAIN.ShaderTerrain;this.terrainShader.uniforms.env.value=THREE.ImageUtils.loadTexture("./images/spherical/e_chrome.jpg");
this.terrainShader.uniforms.reflectivity.value=0.3;this.terrainShader.uniforms.enableReflection.value=!0;this.terrainShader.uniforms.oceanTexture.value=this.textures[0];this.terrainShader.uniforms.sandyTexture.value=this.textures[1];this.terrainShader.uniforms.grassTexture.value=this.textures[2];this.terrainShader.uniforms.rockyTexture.value=this.textures[3];this.terrainShader.uniforms.snowyTexture.value=this.textures[4];this.terrainShader.uniforms.tNormal.value=this.normalMap;this.terrainShader.uniforms.uNormalScale.value=
3.5;this.terrainShader.uniforms.tDisplacement.value=this.heightMap;this.terrainShader.uniforms.tDiffuse1.value=this.textures[5];this.terrainShader.uniforms.tDiffuse2.value=this.textures[6];this.terrainShader.uniforms.tSpecular.value=this.specularMap;this.terrainShader.uniforms.tDetail.value=this.textures[7];this.terrainShader.uniforms.enableDiffuse1.value=!0;this.terrainShader.uniforms.enableDiffuse2.value=!0;this.terrainShader.uniforms.enableSpecular.value=!0;this.terrainShader.uniforms.diffuse.value.setHex(3158064);
this.terrainShader.uniforms.specular.value.setHex(1118481);this.terrainShader.uniforms.ambient.value.setHex(1052688);this.terrainShader.uniforms.shininess.value=20;this.terrainShader.uniforms.uDisplacementScale.value=this.size[1];this.terrainShader.uniforms.uRepeatOverlay.value.set(12,12);this.debug&&(this.m1.material.map=this.heightMap,this.m2.material.map=this.normalMap,this.m3.material.map=this.specularMap,this.m1.material.needsUpdate=!0,this.m2.material.needsUpdate=!0,this.m3.material.needsUpdate=
!0,this.m1.visible=!0,this.m2.visible=!0,this.m3.visible=!0);for(var a=[["heightmap",this.noiseShader.fs,this.noiseShader.vs,this.noiseShader.uniforms,!1],["normal",this.normalShader.fs,this.normalShader.vs,this.normalShader.uniforms,!1],["specular",this.specularShader.fs,this.specularShader.vs,this.specularShader.uniforms,!1],["terrain",this.terrainShader.fs,this.terrainShader.vs,this.terrainShader.uniforms,!0]],b,c=a.length;c--;)b=new THREE.ShaderMaterial({uniforms:a[c][3],vertexShader:a[c][2],
fragmentShader:a[c][1],lights:!1,fog:!1}),this.mlib[a[c][0]]=b;this.mlib.terrain.transparent=!0;a=new THREE.PlaneBufferGeometry(this.W,this.H);this.quadTarget=new THREE.Mesh(a,new THREE.MeshBasicMaterial({color:0}));this.quadTarget.position.z=-500;this.sceneRenderTarget.add(this.quadTarget);this.mlib.terrain.isActive=!0;this.mesh.material=this.mlib.terrain;this.mesh.visible=!0;env&&env.add(terrain.mlib.terrain);this.fullLoaded=!0;this.update(1)},easing:function(){var a=this.main.nav.key,b=this.main.clock.getDelta(),
c=this.main.nav.cam.theta;this.maxspeed=a.shift?5:1;a.up&&(this.ease.y-=this.acc);a.down&&(this.ease.y+=this.acc);a.left&&(this.ease.x-=this.acc);a.right&&(this.ease.x+=this.acc);this.ease.x>this.maxspeed&&(this.ease.x=this.maxspeed);this.ease.y>this.maxspeed&&(this.ease.y=this.maxspeed);this.ease.x<-this.maxspeed&&(this.ease.x=-this.maxspeed);this.ease.y<-this.maxspeed&&(this.ease.y=-this.maxspeed);a.up||a.down||(this.ease.y=this.ease.y>this.dec?this.ease.y-this.dec:this.ease.y<-this.dec?this.ease.y+
this.dec:0);a.left||a.right||(this.ease.x=this.ease.x>this.dec?this.ease.x-this.dec:this.ease.x<-this.dec?this.ease.x+this.dec:0);if(0!=this.ease.x||0!=this.ease.z)this.pos.x+=0.01*(Math.sin(c)*this.ease.x+Math.cos(c)*this.ease.y),this.pos.y+=0.01*(Math.cos(c)*this.ease.x-Math.sin(c)*this.ease.y),this.update(b)},move:function(a,b,c){this.pos.x=a;this.pos.y=b;this.update(c)},update:function(a){this.fullLoaded&&(Date.now(),this.lightVal=THREE.Math.clamp(this.lightVal+0.5*a*this.lightDir,0.01,0.8),this.terrainShader.uniforms.uNormalScale.value=
THREE.Math.mapLinear((this.lightVal-0.01)/0.79,0,1,0.6,3.5),this.updateNoise&&(this.animDelta=THREE.Math.clamp(this.animDelta+7.5E-4*this.animDeltaDir,0,0.05),this.noiseShader.uniforms.time.value+=a*this.animDelta,this.noiseShader.uniforms.offset.value.set(this.pos.x,this.pos.y),this.terrainShader.uniforms.uOffset.value.set(8*this.pos.x,8*this.pos.y),this.quadTarget.material=this.mlib.heightmap,this.main.renderer.render(this.sceneRenderTarget,this.cameraOrtho,this.heightMap,!0),this.isWithDepthTest&&
(a=this.main.renderer.getContext(),a.readPixels(0,0,this.div[0],this.div[1],a.RGBA,a.UNSIGNED_BYTE,this.tmpData)),this.quadTarget.material=this.mlib.normal,this.main.renderer.render(this.sceneRenderTarget,this.cameraOrtho,this.normalMap,!0),this.quadTarget.material=this.mlib.specular,this.main.renderer.render(this.sceneRenderTarget,this.cameraOrtho,this.specularMap,!0)))},anim:function(){this.animDeltaDir*=-1},night:function(){this.lightDir*=-1},getz:function(a,b){if(null==this.tmpData)return 0;var c=
4*Math.floor((Math.floor((-b/this.size[2]+0.5)*this.div[1])-1)*this.div[0]+Math.floor((a/this.size[0]+0.5)*this.div[0]));return(this.tmpData[c+0]+this.tmpData[c+1]+this.tmpData[c+2])*this.ratio}};
TERRAIN.NormalMapShader={uniforms:{heightMap:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(128,128)},scale:{type:"v2",value:new THREE.Vector2(0,0)},height:{type:"f",value:0.05}},vs:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fs:"uniform float height;\nuniform vec2 resolution;\nuniform sampler2D heightMap;\nvarying vec2 vUv;\nvoid main() {\nfloat val = texture2D( heightMap, vUv ).x;\nfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\nfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\ngl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\n}"};
TERRAIN.ShaderNoise={uniforms:{time:{type:"f",value:1},scale:{type:"v2",value:new THREE.Vector2(1.5,1.5)},offset:{type:"v2",value:new THREE.Vector2(0,0)}},fs:"uniform float time;\nvarying vec2 vUv;\nvec4 permute( vec4 x ) {\nreturn mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\n}\nvec4 taylorInvSqrt( vec4 r ) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise( vec3 v ) {\nconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\nconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n// First corner\nvec3 i  = floor( v + dot( v, C.yyy ) );\nvec3 x0 = v - i + dot( i, C.xxx );\n// Other corners\nvec3 g = step( x0.yzx, x0.xyz );\nvec3 l = 1.0 - g;\nvec3 i1 = min( g.xyz, l.zxy );\nvec3 i2 = max( g.xyz, l.zxy );\nvec3 x1 = x0 - i1 + 1.0 * C.xxx;\nvec3 x2 = x0 - i2 + 2.0 * C.xxx;\nvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n// Permutations\ni = mod( i, 289.0 );\nvec4 p = permute( permute( permute(\n i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n+ i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n+ i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\nfloat n_ = 1.0 / 7.0; // N=7\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\nvec4 x_ = floor( j * ns.z );\nvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\nvec4 x = x_ *ns.x + ns.yyyy;\nvec4 y = y_ *ns.x + ns.yyyy;\nvec4 h = 1.0 - abs( x ) - abs( y );\nvec4 b0 = vec4( x.xy, y.xy );\nvec4 b1 = vec4( x.zw, y.zw );\nvec4 s0 = floor( b0 ) * 2.0 + 1.0;\nvec4 s1 = floor( b1 ) * 2.0 + 1.0;\nvec4 sh = -step( h, vec4( 0.0 ) );\nvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\nvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\nvec3 p0 = vec3( a0.xy, h.x );\nvec3 p1 = vec3( a0.zw, h.y );\nvec3 p2 = vec3( a1.xy, h.z );\nvec3 p3 = vec3( a1.zw, h.w );\n// Normalise gradients\nvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\n// Mix final noise value\nvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\nm = m * m;\nreturn 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) ) );\n}\nfloat surface3( vec3 coord ) {\nfloat n = 0.0;\nn += 1.0 * abs( snoise( coord ) );\nn += 0.5 * abs( snoise( coord * 2.0 ) );\nn += 0.25 * abs( snoise( coord * 4.0 ) );\nn += 0.125 * abs( snoise( coord * 8.0 ) );\nreturn n;\n}\nvoid main( void ) {\nvec3 coord = vec3( vUv, -time );\nfloat n = surface3( coord );\ngl_FragColor = vec4( vec3( n, n, n ), 1.0 );\n}",
vs:"varying vec2 vUv;\nuniform vec2 scale;\nuniform vec2 offset;\nvoid main( void ) {\nvUv = uv * scale + offset;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"};TERRAIN.LuminosityShader={uniforms:{tDiffuse:{type:"t",value:null}},vs:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fs:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat v = dot( texel.xyz, luma );\ngl_FragColor = vec4( v, v, v, texel.w );\n}"};
TERRAIN.ShaderTerrain={uniforms:{env:{type:"t",value:null},enableReflection:{type:"i",value:0},useRefract:{type:"i",value:0},reflectivity:{type:"f",value:1},refractionRatio:{type:"f",value:0.98},combine:{type:"i",value:0},fogcolor:{type:"c",value:new THREE.Color(2435374)},oceanTexture:{type:"t",value:null},sandyTexture:{type:"t",value:null},grassTexture:{type:"t",value:null},rockyTexture:{type:"t",value:null},snowyTexture:{type:"t",value:null},enableDiffuse1:{type:"i",value:0},enableDiffuse2:{type:"i",
value:0},enableSpecular:{type:"i",value:1},enableFog:{type:"i",value:1},tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDetail:{type:"t",value:null},tNormal:{type:"t",value:null},tSpecular:{type:"t",value:null},tDisplacement:{type:"t",value:null},uNormalScale:{type:"f",value:1},uDisplacementBias:{type:"f",value:0},uDisplacementScale:{type:"f",value:1},diffuse:{type:"c",value:new THREE.Color(15658734)},specular:{type:"c",value:new THREE.Color(16716049)},ambient:{type:"c",value:new THREE.Color(328965)},
shininess:{type:"f",value:30},opacity:{type:"f",value:1},vAmount:{type:"f",value:30},uRepeatBase:{type:"v2",value:new THREE.Vector2(1,1)},uRepeatOverlay:{type:"v2",value:new THREE.Vector2(1,1)},uOffset:{type:"v2",value:new THREE.Vector2(0,0)}},fs:"uniform sampler2D env;\nuniform sampler2D oceanTexture;\nuniform sampler2D sandyTexture;\nuniform sampler2D grassTexture;\nuniform sampler2D rockyTexture;\nuniform sampler2D snowyTexture;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nuniform bool enableReflection;\nuniform bool enableFog;\nvarying float vAmount;\nuniform vec3 fogcolor;\nuniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse1;\nuniform bool enableDiffuse2;\nuniform bool enableSpecular;\nuniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nuniform sampler2D tDetail;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tDisplacement;\nuniform float uNormalScale;\nuniform vec2 uRepeatOverlay;\nuniform vec2 uRepeatBase;\nuniform vec2 uOffset;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec2 vN;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvoid main() {\nvec2 uvOverlay = uRepeatOverlay * vUv + uOffset;\nvec2 uvBase = uRepeatBase * vUv;\nvec4 water = (smoothstep(0.01, 0.20, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, uvOverlay );\nvec4 sandy = (smoothstep(0.10, 0.30, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, uvOverlay );\nvec4 grass = (smoothstep(0.28, 0.40, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, uvOverlay );\nvec4 rocky = (smoothstep(0.30, 0.76, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, uvOverlay );\nvec4 snowy = (smoothstep(0.80, 0.99, vAmount))                                   * texture2D( snowyTexture, uvOverlay );\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse1 && enableDiffuse2 ) {\nvec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );\nvec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );\ngl_FragColor = gl_FragColor * mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );\ngl_FragColor = vec4( gl_FragColor.xyz, 1.0 )+ water + sandy + grass + rocky + snowy;\n } else if( enableDiffuse1 ) {\ngl_FragColor = gl_FragColor * texture2D( tDiffuse1, uvOverlay );\n} else if( enableDiffuse2 ) {\ngl_FragColor = gl_FragColor * texture2D( tDiffuse2, uvOverlay );\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, uvOverlay ).xyz;\nmat3 tsb = mat3( vTangent, vBinormal, vNormal );\nvec3 finalNormal = tsb * normalTex;\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\nif ( enableReflection ) {\nvec3 ev = texture2D( env, vN ).rgb;\ngl_FragColor.xyz = mix( gl_FragColor.xyz, ev.xyz, reflectivity );\n}\nif(enableFog){\nfloat circle_radius_min = 0.3;\nfloat circle_radius_max = 0.5;\nfloat fogDensity = 0.4;\nfloat fog_far = 30.4;\nvec2 nuv = vUv - vec2(0.5, 0.5);\nfloat dist =  sqrt(dot(nuv, nuv));\nfloat fog = 0.0;\nif ( dist > circle_radius_min )\nfog =(dist-circle_radius_min)*5.0;\ngl_FragColor = vec4(gl_FragColor.xyz, 1.-fog);\n}\n}",
vs:"attribute vec4 tangent;\nuniform vec2 uRepeatBase;\nuniform sampler2D tNormal;\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying float vAmount;\nvarying vec2 vN;\nvarying vec3 vPos;\nvoid main() {\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\nvBinormal = cross( vNormal, vTangent ) * tangent.w;\nvBinormal = normalize( vBinormal );\nvUv = uv;\nvec4 bumpData = texture2D( tDisplacement, uv );\nvAmount = bumpData.r;\nvec2 uvBase = uv * uRepeatBase;\nvec3 dv = texture2D( tDisplacement, uvBase ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\nvec3 displacedPosition = normal * df + position;\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\nvec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;\nvNormal = normalMatrix * normalTex;\nvPos = normalize( vec3( mvPosition ) );\nvec3 r = reflect( vPos, normalize(vNormal) );\nfloat m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );\nvN = r.xy / m + .5;\n}"};
