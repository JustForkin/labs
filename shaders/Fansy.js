V.Fansy={
uniforms:{
texTireDiff: { type: 't', value: null },
texTireNorm: { type: 't', value: null },
texTireSpec: {  type: 't', value: null },
cubeSpec: { type: 't', value: null },
cubeAmb: {  type: 't', value: null },
ambPow: { type: 'f', value:0.79  },
ambGamma: { type: 'f', value:0.87},
refPower: { type: 'f', value:0.83  },
refGamma: { type: 'f', value:2.4 },
refRPow: { type: 'f', value:5.0 },
refRBias: { type: 'f', value:0.03 },
glossiness: { type: 'f', value:15.3 },
specPower: { type: 'f', value:0.32},
pointLightPosition: { type: 'v3', value: new THREE.Vector3(-45,45,60) },
timer1: { type: 'f', value: 0 },
lightIntensity: { type: 'f', value:0.4 },
FresnelPower: {  type: 'f', value:4.2 },
FresnelIntensity: { type: 'f',  value:0.57 },
FresnelColor: { type: 'c',  value: new THREE.Color() },
choiceTexture: {  type: 'i', value: 0 },
choiceShowNormal: {  type: 'i', value: 0 },
choiceNormal: { type: 'i', value: 1 }
},
fs: [
'uniform samplerCube cubeAmb;',
'uniform sampler2D texTireDiff;',
'uniform sampler2D texTireNorm;',
'uniform sampler2D texTireSpec;',
'uniform float refPower;',
'uniform float refGamma;',
'uniform float refRBias;',
'uniform float refRPow;',
'uniform float ambPow;',
'uniform float ambGamma;',
'uniform float glossiness;',
'uniform float specPower;',
'uniform float lightIntensity;',
'uniform float FresnelPower;',
'uniform float FresnelIntensity;',
'uniform vec3 FresnelColor;',
'uniform int choiceNormal;',
'uniform int choiceShowNormal;',
'varying vec3 vViewDirWorld;',
'varying vec2 vUv;',
'varying vec3 vTangent;',
'varying vec3 vBinormal;',
'varying vec3 vNormal;',
'varying vec3 vLightPos;',
'varying vec3 vViewPosition;',
'void main(){',
	'vec2 uv2 = vUv;',
	'vec3 texNormal = texture2D( texTireNorm, vUv ).xyz * 2.0 - vec3(1.0, 1.0, 1.0);',
	'texNormal = normalize( texNormal );',
	'mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );',
	'vec3 finalNormal;',
	'if (choiceNormal == 0) {',
		'finalNormal = vNormal;',
	'} else if (choiceNormal == 1){',
		'finalNormal = tsb * texNormal;',
	'};',
	'vec3 normalDir = normalize(finalNormal);',
	'vec3 viewDir = normalize( vViewPosition );',
	'vec3 texDiff = texture2D(texTireDiff, vUv).xyz;',
	'vec3 texSpec = texture2D(texTireSpec, vUv).xyz;',
	'vec3 lightDir;',
	'lightDir = normalize(vLightPos);',
	'float rimRef = 1.0 - clamp(dot(viewDir, normalDir), 0.0, 1.0);',
	'float albedoFresnel = pow(rimRef, FresnelPower);',
	'albedoFresnel *= FresnelIntensity;',
	'vec3 cAlbedoFresnel = FresnelColor * albedoFresnel;',
	'rimRef = pow(rimRef, refRPow);',
	'rimRef = rimRef*(1.0-refRBias)+refRBias;',
 	'float NdotL = clamp(dot(normalDir, lightDir), 0.0, 1.0);',
 	'NdotL *= lightIntensity;',
 	'vec3 h = normalize(lightDir + viewDir);',
 	'float spec = clamp(dot(normalDir, h), 0.0, 1.0);',
	'spec = pow(spec, glossiness)*NdotL;',
	'spec *= specPower*2.0;',
 	'vec3 reflectVec = reflect( viewDir, normalDir );',
	'vec3 specCube = textureCube( cubeAmb, vec3( reflectVec.x, -reflectVec.yz ) ).xyz;',
	'specCube = pow(specCube, vec3(refGamma, refGamma, refGamma));',
	'specCube *= rimRef;',
	'specCube *= refPower;',
	'vec3 ambCube = textureCube( cubeAmb, vec3( reflectVec.x, -reflectVec.yz ) ).xyz;',
	'ambCube = pow(ambCube, vec3(ambGamma,ambGamma,ambGamma));',
	'ambCube *= ambPow;',
	'vec3 lightCol = texDiff*NdotL;',
	'lightCol += texDiff * ambCube;',
	'lightCol += specCube;',
	'lightCol += spec;',
	'lightCol = mix( lightCol, cAlbedoFresnel, vec3(albedoFresnel));',
	'if (choiceShowNormal == 0){',
		'gl_FragColor = vec4(lightCol,1.0);',
	'} else if (choiceShowNormal == 1 ){',
		'gl_FragColor = vec4(normalDir,1.0);',
	'} else if (choiceShowNormal == 2 ){',
		'gl_FragColor = vec4(vUv, 0.0, 1.0);',
	'}',
'}'
].join('\n'),
vs: [
'attribute vec4 tangent;',
'uniform vec3 pointLightPosition;',
'uniform float timer1;',
'varying vec3 vViewDirWorld;',
'varying vec3 vWorldPosition;',
'varying vec3 vTangent;',
'varying vec3 vBinormal;',
'varying vec3 vNormal;',
'varying vec2 vUv;',
'varying vec3 vLightPos;',
'varying vec3 vViewPosition;',
'void main(){',
	'vUv = uv;',
	'vNormal = normalize( normalMatrix * normal );',
	'vTangent = normalize( normalMatrix * tangent.xyz );',
	'vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );',

	'vWorldPosition = (modelMatrix * vec4( position, 1.0 )).xyz;',

	'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
	'vViewPosition = -mvPosition.xyz;',
	'vViewDirWorld = normalize( vWorldPosition - vec4( modelViewMatrix*vec4(cameraPosition,1.0) ).xyz);',

	'vLightPos = normalize(vec3(30,-30,30));',
	'vec2 circleMotion;',
	'float anim = timer1;',
	'circleMotion.x = cos(anim);',
	'circleMotion.y = sin(anim);',
	'vLightPos = normalize(vec3(circleMotion.y, .65, circleMotion.x));',
	'vLightPos = (viewMatrix * vec4(vLightPos, 0.0)).xyz;',

	'gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);',
'}'
].join('\n')
}